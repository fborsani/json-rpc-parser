package jsonrpc.deparser.decoders;

import jsonrpc.deparser.ExceptionInvalidRequest;
import jsonrpc.deparser.ExceptionDeparse;

import java.util.HashMap;
import jsonrpc.deparser.IDecoder;

/**
 * Decoder that translates json-rpc requests and notifications.
 * @author fborsani
 */

public class DecoderRequest implements IDecoder{
    
    private ExceptionDeparse error = null;
    private boolean isNamed = true;
    
    public DecoderRequest(boolean isNamed){this.isNamed = isNamed;}
    
    @Override
    public ExceptionDeparse getError(){ return error;}
    
    /**
     * Main decoder method
     * 
     * @param elements a json-rpc string split by the TranslatorHelper class
     * 
     * @return an HashMap where every json-rpc keyword (jsonrpc, method, id) is
     * associated with its value. If the decoder is set to operate in 
     * namedParams mode all parameters will have their name associated with 
     * their value, else if the parameters are positional the key associated
     * with their value will be the string "p"+i where i is their position 
     * in the sub-array generated by the TranslatorHelper class
     */
    
    @Override
    public HashMap<String,String> decode(String[][] elements){
        try{

            HashMap<String,String> decodedMap = new HashMap<>();
            String[] keywords = {"jsonrpc","method","params","id"};
            int fields=0;

            while(fields < elements.length && elements[fields] != null) ++fields;
            
            switch(fields){
                case 1: //no parameters
                    for(int i=0,k=0;i<elements[0].length;i+=2,++k){ //i = position in array k = current expected keyword
                        if(k==2) ++k; //skip "param" keyword
                        
                        if(i+1 < elements[0].length && elements[0][i].equals(keywords[k]) && elements[0][i+1] != null)
                            decodedMap.put(elements[0][i], elements[0][i+1]);
                        else throw new ExceptionInvalidRequest("Invalid "+keywords[k]+" field"); 
                    }
                    break;
                    
                case 2: //parameter field 
                case 3:
                    for(int f=0,k=0;f<fields;++f){  //f = current field k = current expected keyword
                        for(int i=0;i<elements[f].length;i+=2,++k){
                            
                            if(elements[f][i].equals(keywords[2]) && f+1 < elements[f].length){ //process parameters field
                                ++f;
                                
                                for(int j=0;j<elements[f].length;++j){      
                                    if(isNamed && j+1 < elements[f].length && elements[f][j+1] != null){
                                        decodedMap.put(elements[f][j], elements[f][j+1]);
                                        ++j;    //skip argument position
                                    }
                                    else if(!isNamed) 
                                        decodedMap.put("p"+j, elements[f][j]);
                                    else throw new ExceptionInvalidRequest("Param in position "+j+" is invalid");                                                                          
                                }
                            }                        
                            else if(i+1 < elements[f].length && elements[f][i].equals(keywords[k]) && elements[f][i+1] != null)
                                decodedMap.put(elements[f][i], elements[f][i+1]);
                            else throw new ExceptionInvalidRequest("Invalid "+keywords[k]+" field");
                        }
                    }
                    break;
                default:
                    throw new ExceptionInvalidRequest("String is malformed or empty");
            }
            return decodedMap; 
        }
        catch(ExceptionInvalidRequest e){
            error = e;
            return null;
        }
    }
}